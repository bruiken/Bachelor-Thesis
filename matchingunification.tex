\chapter{Matching and Unification}\label{matching-unification}
The first non-termination detection techniques we will look at are matching and unification. These two techniques have the same core idea, namely to check for all the rules if the left side matches or unifies with any non-variable position on the right side. We will see that if this is the case, we can already conclude non-termination of the rewriting system.

\section{Matching}
Unlike unification, we have not looked at matching yet. Matching can be seen as a more restricted form of unification. A term $t_1$ matches with another term $t_2$, if there exists a substitution $\sigma_1$ such that $\sigma_1(t_1) = t_2$. Instead of applying the substitution to both terms, it only is applied to one.

Matching can be used to detect non-termination, if for some rule, the left side matches with a non variable subterm on the right, we know it is non-terminating. This is because we can repeatedly apply the rule on the chosen subterm.

\textbf{Example 4.1}: Consider the rule $r_1: f(x) \rightarrow g(1, f(h(x)))$. We can take the subterm $t_1 = f(h(x))$ and check if there is a $\sigma_1$ for which holds that $\sigma_1(f(x)) = f(h(x))$. Choose $\sigma_1 = \{ h(x) \leftarrow x \}$ and this holds. The infinite reduction then looks like (for example) $f(1) \rightarrow_R g(1, f(h(1))) \rightarrow_R g(1, g(1, f(h(h(1))))) \rightarrow_R \dots$. So we conclude that $r_1$ is non-terminating. 

Cora already has matching built into it since it is also required to check if a rule can be applied to a term. Note that when applying a rule, you match the left hand side of the rule with the term you want to apply it on, and finally apply the resulting substitution on the right hand side of the rule.

The algorithm to match two terms is given in Algorithm \ref{matching} on page \pageref{matching}. This is the algorithm as implemented in Cora. Note that this algorithm does not mention any types. The type checks are embedded in comparisons between terms. Also note that when recursively calling \texttt{match} on line 19, $\sigma$ is not initialised to $\emptyset$ in the new call. The given substitution from the recursive call is used instead.

As noted above, the matching algorithm was already built into Cora, but it was not implemented as an analyser yet. In Mara it is, called the \texttt{MatchingAnalyser}. 

\begin{algorithm}
\caption{Matching}
\label{matching}
\begin{algorithmic}[1]
\STATE Input terms $t_1$ and $t_2$, initialise $\sigma = \emptyset$
\IF {$t_1$ is a variable}
  \IF {$\sigma$ contains $t_1$}
    \IF {$\sigma(t_1) \neq t_2$}
      \STATE \textbf{throw} Failure
    \ENDIF
  \ELSE
    \STATE $\sigma(t_1) := t_2$
    \RETURN $\sigma$
  \ENDIF
\ELSIF {$t_1$ is in the form of $f(x_1, \dots, x_n)$, $n$ being the arity of $f$}
  \IF {$t_2$ is a variable}
    \STATE \textbf{throw} Failure
  \ELSIF {$t_2$ is in the form of $g(y_1, \dots, y_m)$, $m$ being the arity of $g$}
    \IF {$f \neq g$}
      \STATE \textbf{throw} Failure
    \ENDIF
    \FORALL {$i \in \left[1, n\right]$}
      \STATE match $x_i$ with $y_i$ using $\sigma$
      \RETURN $\sigma$
    \ENDFOR
  \ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

\section{Unification}
Similarly to matching, we can also apply unification to detect non-termination of term rewriting systems. Recall that unification of two terms $t_1$ and $t_2$ is possible when we can find a $\sigma$ such that $\sigma(t_1) = \sigma(t_2)$. We know that if the left hand side of a rule unifies with some non variable subterm of the right hand side, the TRS is non-terminating, for the following reason: suppose that we have a rule $r_1: l \rightarrow r$, and that there is some non-variable subterm $r'$ of $r$ and that there is a substitution $\sigma$ such that $\sigma(l) = \sigma(r')$. We can now create an infinite loop: apply $r_1$ to $\sigma(l)$, then apply $r_1$ to the result of that and repeat this process\dots.

\textbf{Example 4.2}: Take the rule $r_1: f(g(x), z, y) \rightarrow f(y, g(x), y)$. To try to unify the left side with some non-variable subterm on the right, the most sensible subterm to choose is the entire right side. We can unify these two sides by taking $\sigma = \{ g(x) \leftarrow y, g(x) \leftarrow z \}$. If we apply $r_1$ to $\sigma(f(g(x), z, y)) = f(g(x), g(x), g(x))$, we get $f(g(x), g(x), g(x))$ back, which can immediately be applied to $r_1$ again; this clearly keeps looping indefinitely.

Implementing the unification algorithm that works for many-sorted terms does not require many adaptations from an existing algorithm such as the one from Martelli and Montanari.\cite{Martelli:1982} The algorithm in pseudocode can be found in Algorithm \ref{unification} on page \pageref{unification}. Unlike earlier, type checks are included, but they are not explicitly noted in the comparison between terms and function symbols.  

\begin{algorithm}
\caption{Unification}
\label{unification}
\begin{algorithmic}[1]
\STATE Input terms $t_1$ and $t_2$, initialise $\sigma = \emptyset$
\IF {$t_1$ is a variable}
  \IF {$t_2$ is a variable}
    \IF {$t_1 \neq t_2$}
      \IF {Type of $t_1 \neq$ type of $t_2$}
        \STATE \textbf{throw} Failure
      \ELSE
        \STATE $\sigma(t_2) := t_1$
      \ENDIF
    \ENDIF
    \RETURN $\sigma$
  \ELSE
    \RETURN unify $t_2$, $t_1$
  \ENDIF
\ELSIF {$t_1$ is in the form of $f(s_1, \dots, s_n)$, $n$ being the arity of $f$}
  \IF {$t_2$ is a variable}
    \IF {$t_1$ contains $t_2$ \OR type of $t_1 \neq$ type of $t_2$}
      \STATE \textbf{throw} Failure
    \ELSE 
      \STATE $\sigma(t_2) := t_1$
      \RETURN $\sigma$
    \ENDIF
  \ELSIF {$t_2$ is in the form of $g(u_1, \dots, u_m)$, $m$ being the arity of $g$}
    \IF {$f \neq g$}
      \STATE \textbf{throw} Failure
    \ENDIF
    \FORALL {$i \in \left[1, n\right]$}
      \STATE $\gamma$ := unify $\sigma(s_i)$ with $\sigma(u_i)$
      \FORALL {Variable $v$ in domain of $\gamma$ }  
        \IF {$v$ in domain of $\sigma$ \AND $\sigma(v) \neq \gamma(v)$}
          \STATE \textbf{throw} Failure
        \ELSE
          \STATE $\sigma(v) := \gamma(v)$
        \ENDIF
      \ENDFOR
    \ENDFOR
    \RETURN $\sigma$
  \ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

This algorithm is implemented and can be used in an analyser. The only thing the analyser needs to do is check for every rule, whether the left side unifies with some non-variable subterm of the right hand side. This is implemented in the \texttt{UnificationAnalyser}.