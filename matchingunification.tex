\chapter{Matching and Unification}\label{matching-unification}
The first non-termination detection techniques we will look at are matching and unification. These two techniques have the same core idea, namely to check for all the rules if the left side matches or unifies with any non-variable position on the right side. We will see that if this is the case, we can already state non-termination of the rewriting system.

\section{Matching}
Unlike unification, we have not looked at matching yet. Matching can be seen as a more restricted form of unification. A term $t_1$ matches with another term $t_2$, if there exists a substitution $\sigma_1$ such that $\sigma_1(t_1) = t_2$. Instead of applying the substitution to both terms, it only is applied to one.

Matching can be used to detect non-termination, if for some rule, the left side matches a non variable subterm on the right, we know it is non-terminating. This is because we can repeatedly apply the rule on the chosen subterm.

\textbf{Example 4.1}: Take the rule $r_1: f(x) \rightarrow g(1, f(h(x)))$, we can take the subterm $t_1 = f(h(x))$ and check if there is a $\sigma_1$ for which holds that $\sigma_1(f(x)) = f(h(x))$. Choose $\sigma_1 = \{ h(x) \leftarrow x \}$ and this holds. So we conclude that $r_1$ is non-terminating. 

Cora already has matching built into it since it is also required to check if a rule can be applied to a term. Note that when applying a rule, you match the left hand side of the rule with the term you want to apply it on, and finally apply the resulting substitution on the right hand side of the rule.

The algorithm to match two terms is given in Algorithm \ref{matching} on page \pageref{matching}. Note that this algorithm does not mention any types. It is trivial to include the types, however. We just need to make sure that in every comparison, the types are also checked:
\begin{enumerate}
    \itemsep0em
    \item Between lines 2 and 3 a check needs to be done to compare the types of $t_1$ and $t_2$,
    \item If the \texttt{if} statement at line 4 holds, then we still need to check if the types of $\sigma(t_1)$ and $t_2$ match,
    \item Comparison of terms need to include type checking (e.g. in line 4),
    \item Comparison of function symbols need to include type checking (e.g. in line 14).
\end{enumerate}
As noted above, the matching algorithm (including the type checks) was already built into Cora, but it was not implemented as an analyser yet. Now it is, though, called the \texttt{MatchingAnalyzer}. 

\begin{algorithm}
\caption{Matching}
\label{matching}
\begin{algorithmic}[5]
\STATE Input terms $t_1$ and $t_2$, initialize $\sigma = \emptyset$
\IF {$t_1$ is a variable}
  \IF {$\sigma$ contains $t_1$}
    \IF {$\sigma(t_1) \neq t_2$}
      \RETURN Failure
    \ENDIF
  \ELSE
    \STATE $\sigma(t_1) = t_2$
  \ENDIF
\ELSIF {$t_1$ is in the form of $f(x_1, \dots, x_n)$, $n$ being the arity of $f$}
  \IF {$t_2$ is a variable}
    \RETURN Failure
  \ELSIF {$t_2$ is in the form of $g(y_1, \dots, y_m)$, $m$ being the arity of $g$}
    \IF {$f \neq g$ \OR $m \neq n$}
      \RETURN Failure
    \ENDIF
    \FORALL {$i \in \left[1, n\right]$}
      \STATE match $x_i$ with $y_i$ using $\sigma$
    \ENDFOR
  \ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

\section{Unification}
Similarly to matching, we can also apply unification to detect non-termination of term rewriting systems. Recall that unification of two terms $t_1$ and $t_2$ is possible when we can find a $\sigma$ such that $\sigma(t_1) = \sigma(t_2)$. We know that if the left hand side of a rule unifies with some non variable subterm of the right hand side, the TRS is non-terminating.\newline
Suppose that we have a rule $r_1: t_1 \rightarrow t_2$, and that there is some non-variable subterm $t_2'$ of $t_2$ and that there is a substitution $\sigma$ such that $\sigma(t_1) = \sigma(t_2')$. We can now create an infinite loop: apply $r_1$ to $\sigma(t_1)$, then apply $r_1$ to the result of that\dots.

\textbf{Example 4.2}: Take the rule $r_1: f(g(x), z, y) \rightarrow f(y, g(x), y)$. To try to unify the left side with some non-variable subterm on the right, the most sensible subterm to choose is the entire right side. We can unify these two sides by taking $\sigma = \{ g(x) \leftarrow y, g(x) \leftarrow z \}$. If we apply $r_1$ to $\sigma(f(g(x), z, y)) = f(g(x), g(x), g(x))$, we get $f(g(x), g(x), g(x))$ back, which can immediately be applied to $r_1$ again, this clearly keeps looping indefinitely.

Implementing the unification algorithm that works for many-sorted terms does not require many adaptations from an existing algorithm such as the one from Martelli and Montanari.\cite{Martelli:1982} The algorithm in pseudocode can be found in Algorithm \ref{unification} on page \pageref{unification}. Unlike earlier, type checks are included, but they are not explicitly noted in the comparison between terms and function symbols (e.g. lines 4 and 24).  

\begin{algorithm}
\caption{Unification}
\label{unification}
\begin{algorithmic}[5]
\STATE Input terms $t_1$ and $t_2$, initialize $\sigma = \emptyset$
\IF {$t_1$ is a variable}
  \IF {$t_2$ is a variable}
    \IF {$t_1 \neq t_2$}
      \IF {Type of $t_1 \neq$ type of $t_2$}
        \RETURN Failure
      \ELSE
        \STATE $\sigma(t_2) = t_1$
      \ENDIF
    \ENDIF
  \ELSE
    \RETURN unify $t_2$, $t_1$ using $\sigma$
  \ENDIF
\ELSIF {$t_1$ is in the form of $f(x_1, \dots, x_n)$, $n$ being the arity of $f$}
  \IF {$t_2$ is a variable}
    \IF {$t_1$ contains $t_2$}
      \RETURN Failure
    \ELSIF {Type of $t_1 \neq$ type of $t_2$}
      \RETURN Failure
    \ELSE 
      \STATE $\sigma(t_2) = t_1$
    \ENDIF
  \ELSIF {$t_2$ is in the form of $g(y_1, \dots, y_m)$, $m$ being the arity of $g$}
    \IF {$f \neq g$ \OR $m \neq n$}
      \RETURN Failure
    \ENDIF
    \FORALL {$i \in \left[1, n\right]$}
      \STATE unify $x_i$ with $y_i$ using $\sigma$
      \STATE update replacements in $\sigma$ using the just added terms to it
    \ENDFOR
  \ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

This algorithm is implemented and can be used in an analyser. The only thing the analyser needs to do is check for every rule, if the left side unifies with some non-variable subterm of the right hand side. This is implemented in the \texttt{UnificationAnalyzer}.