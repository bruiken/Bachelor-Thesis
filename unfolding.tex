\chapter{Unfolding}\label{unfolding}
Unfolding is yet another method to detect non-termination. However, this time the method does not detect non-termination by itself. Rather it makes use of our previously defined method semi-unification. The unfolding technique, as it name suggests, unfolds a term rewriting system in such a way that we can use semi-unification on the resulting rules. Intuitively, we can see this as creating existing rules where we apply rules on the right hand sides. We will follow Payet's paper\cite{Payet:Unfolding}, and adapt the technique where needed for many-sorted terms. 

The paper defines two main techniques: firstly a ``normal'' unfolding (which we will refer to as concrete unfolding), then an improved version upon that called abstract unfolding. We will look at both of these and also implement them into analysers. 

\section{Concrete Unfolding}
The concrete unfolding technique has one main operator: the unfolding operator. The definition as in \cite{Payet:Unfolding} is as follows:
\begin{definition}
\label{def:concunf}
\[
T_R(X) = \left\{ \left( l \rightarrow r\left[ r' \right]_p \right)\theta \middle\vert \begin{array}{l} 
l \rightarrow r \in X, \\
p \in \textit{NPos}(r), \\
l' \rightarrow r' \in R \textit{ renamed with fresh variables}, \\
\theta \in mgu(\left.r\right|_p, l')
\end{array}
\right\} 
\]
Where $\textit{NPos}(r)$ gives back all the non variable positions and $r\left[ r'\right]_p$ means replacing position $p$ in $r$ with $r'$. 
\end{definition}

From this an unfolding sequence can be created. The idea is to feed the result of an unfolding into the next step as follows. 
\begin{definition}
The unfolding sequence is inductively defined as follows:
$$T_R \uparrow 0 = R$$
$$T_R \uparrow (n + 1) = T_R(T_R \uparrow n) \text{ where } n \in \mathbb{N}$$ 
\end{definition}

This operator by itself works as a non-termination analyser. Obviously a limit has to be set on the maximum number of unfoldings. To use this as an analyser, we can first do an unfolding step, then do the same thing as we did with semi-unification: for each non-variable subterm on the right hand side, check if it semi-unifies with the left hand side. 

We can use this operator and do our analysis on the result because it retains the non-termination property of a rewriting system. Intuitively, all we are doing is applying rules on some subterms of right hand sides. And applying rules does retain the non-termination property. 

\textbf{Example 6.1} \textit{We will omit types in this example}. Take the following rewriting system: 
\[
\begin{array}{lrcl}
    r_1: & f(x) & \rightarrow & g(x) \\
    r_2: & g(x) & \rightarrow & f(x)
\end{array}
\]
Clearly, this system is non-terminating: we can indefinitely apply the rules given a term that contains either of the functions $f$ or $g$. Note that the semi-unification analyser will not be able to detect this, as there exist no non-variable subterms on right hand sides that semi-unify with the left hand side. Now let us see what happens when we apply a step of unfolding. We take as $(l \rightarrow r) = r_1$, the position $p = \epsilon$, $l' \rightarrow r'$ with fresh variables $ = g(x') \rightarrow f(x')$. Now we have a most general unifier $\textit{mgu}(g(x), g(x')) = \{ x \leftarrow x' \}$. So our resulting rule is $f(x) \rightarrow f(x)$. We do not have to look any further as the left hand sides semi-unifies with the right hand side: we can take empty substitutions for both $\rho$ and $\sigma$. 

\textbf{Example 6.2} (The same example as in \cite{Payet:Unfolding}, from \cite{TOYAMA1987141}, types are omitted). Take the following rewrite system: 
\[
\begin{array}{lrcl}
    r_1: & f(0, 1, x) & \rightarrow & f(x, x, x) \\
    r_2: & g(x, y) & \rightarrow & x \\
    r_3: & g(x, y) & \rightarrow & y
\end{array}
\]
We know this system is non-terminating (take the term $f(0, 1, g(0, 1))$), but as we will see, our current definition of unfolding is not strong enough to prove non-termination for this example. We start with the first level of unfolding, $T_R \uparrow 0 = R$. At this level we cannot prove non-termination using semi-unification as there is no non-variable position on a right hand side that semi-unifies with the left hand side of that rule. When we try to unfold to the next level, we see that it is not possible to unfold rules $r_2$ and $r_3$, since they do not have a non-variable subterm on the right hand side. $r_1$ also cannot be unfolded, the only non-variable subterm on the right is $f(x, x, x)$. And there is no left hand side of a rule that semi-unifies with that term. So at the first level we already have no terms left.  

As we have just seen, we need some way to pre-process the rules in order to get useful unfoldings. For this, we can use the Augmented TRS (also from \cite{Payet:Unfolding}).  

\section{Augmented Term Rewriting System}
An augmented trs, denoted $R^+$, is a extension of an existing TRS $R$. The idea is to substitute variables in rules with left hand sides from other rules. This way, we know that we will be able to apply rules when unfolding. More precisely:
\begin{definition}
\label{def:augmentedtrs}
For all rules $l \rightarrow r \in R$, create rules $(l \rightarrow r)\theta$ in $R^+$. Here $\theta$ is a substitution in the form of $\{ x_1 \leftarrow t_1, \dots, x_n \leftarrow t_n \}$, where $n \in \mathbb{N}$, $\{ x_1, \dots, x_n \} \in \textit{Var}(l)$ and $t_i$ is a left hand side in $R$ that is variable disjoint from $l \rightarrow r$ and all other $t_j$ in $\theta$. 
\end{definition}

Again we need to make an adaptation to make this work for many-sorted terms. In particular, we only want to replace a variable with some left-hand side if they have the same type. So a substitution $\{ x_i \leftarrow t_i \}$ can only be made if $\textit{type}(x_i) = \textit{type}(t_i)$. Also, note that this augmented system retains the non-termination property of the original TRS. We are basically just creating extra rules where variables are already replaced with terms on which we know we can apply rules.  

To use this augmented TRS in an analyser, we only have to change our initial unfolding step. We defined this as $T_R \uparrow 0 = R$, now we adapt this to $R^+$, such that $T_R \uparrow 0 = R^+$. The other step stays the same: $T_R \uparrow (n + 1) = T_R(T_R \uparrow n)$. 

\textbf{Example 6.3} (Example 6.2 continued): To create the augmented rewrite system using a rewrite system with the rules $r_1$, $r_2$ and $r_3$, we consider the rules one by one. If we look at the first rule, there is only one variable: $x$. We can either not change this variable (leaving us with an empty substitution), replace it with the left hand side of $r_1$, or replace it with the left hand side of $r_2$ (we can ignore $r_3$ as its left hand side is equal to that of $r_2$). So for $r_1$ we have:
$$ \theta_{r_1,0} = \emptyset, \theta_{r_1,1} = \{ f(0, 1, x') \leftarrow x \}, \theta_{r_1,2} = \{ g(x', y') \leftarrow x \}\text{.}$$
The substitutions for the other two rules are going to be equal as their left sides are equal:
\begin{center}
\makebox[0cm]{
\(\begin{array}{rclrcl}
\theta_{r_2,0} & = & \emptyset & \theta_{r_2,5} & = & \{ f(0, 1, x') \leftarrow y, f(0, 1, x'') \leftarrow x \} \\
\theta_{r_2,1} & = & \{ f(0, 1, x') \leftarrow x \}	& \theta_{r_2,6} & = & \{ g(x', y') \leftarrow y, f(0, 1, x'') \leftarrow x \} \\
\theta_{r_2,2} & = & \{ g(x', y') \leftarrow x \} & \theta_{r_2,7} & = & \{ f(0, 1, x') \leftarrow y, g(x'', y') \leftarrow x \} \\
\theta_{r_2,3} & = & \{ f(0, 1, x') \leftarrow y \}	& \theta_{r_2,8} & = & \{ g(x', y') \leftarrow y, g(x'', y'') \leftarrow x \} \\
\theta_{r_2,4} & = & \{ g(x', y') \leftarrow y \}
\end{array}\)
}
\end{center}
The resulting augmented rewrite system then consists of all the substitutions applied on the rules.

\textbf{Example 6.4} (Example 6.3 continued): We can now prove using the augmented rewriting system combined with the unfolding operator, that the rewriting system is non-terminating. Take the rule resulting from the substitution $\theta_{r_1, 2}$ on $r_1$: 
$$f(0, 1, g(x', y')) \rightarrow f(g(x', y'), g(x', y'), g(x', y'))$$
At the first unfolding level we can take position $1.\epsilon$ of the right hand side and the rule $g(x'', y'') \rightarrow x''$ to get to the rule:
$$f(0, 1, g(x', y') \rightarrow f(x', g(x', y'), g(x', y'))$$ 
Then, on the next unfolding level, we can do the same using positon $2.\epsilon$ and the rule $g(x'', y'') \rightarrow y''$. This leads to the rule:
$$f(0, 1, g(x', y')) \rightarrow f(x', y', g(x', y'))$$
Now note that we can semi-unify the two sides by taking $\rho = \emptyset$ and $\sigma = \{ 0 \leftarrow x', 1 \leftarrow y' \}$. Therefore, the TRS does not terminate.

\textbf{Example 6.4} (Example 6.2 continued): Let us now take a look at the same rules \textit{with} typing. We will type the functions as follows:
\[
\begin{array}{rcl}
    f & :: & \alpha \rightarrow \alpha \rightarrow \alpha \rightarrow \alpha \\
    0 & :: & \alpha \\
    1 & :: & \alpha \\
    g & :: & \beta \rightarrow \beta \rightarrow \beta 
\end{array}
\]
Note that the previous example which was non-terminating does not exist anymore, as we cannot use $g$ in an argument of $f$. Furthermore, the rewriting system with these rules \textit{is} terminating. Let us take a look at the augmented system from the rules. It is clear that the new augmented system will have a subset of the rules of the previous example. We just need to cross out all of the substitutions where $g$ is used in $f$ and vice versa:
\begin{center}
\makebox[0cm]{
\(\begin{array}{rclrcl}
    \theta_{r_1,0} & = & \emptyset & \theta_{r_1, 1} & = & \{ f(0, 1, x') \leftarrow x \} \\
    \theta_{r_2,0} & = & \emptyset & \theta_{r_2,1} & = & \{ g(x', y') \leftarrow x \} \\
    \theta_{r_2,2} & = & \{ g(x', y') \leftarrow y \} & \theta_{r_2,3} & = & \{ g(x', y') \leftarrow y, g(x'', y'') \leftarrow x \}
\end{array}\)
}
\end{center}
These augmented rules will result in 11 rules after the first unfolding, then 6 after the second and third, to finally result in 0 resulting rules after the fourth. None of these resulting rules are semi-unifiable. 

\section{Implementation}
The unfolding analyser is implemented in the \texttt{ConcreteUnfoldingAnalyser}. This implementation also includes pre-processing the given TRS into an augmented TRS.  

