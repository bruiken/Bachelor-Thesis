\chapter{Conclusions}\label{conclusions}
We have to look at two separate points in our conclusions. First off, we adapted a number of techniques to work for many-sorted rewriting systems. The second point we can look at is how they perform on examples. 
\section{Adaptations}
The main techniques we have adapted to work for many-sorted term rewriting systems are Concrete unfolding and Abstract unfolding. The impact that the sorts have on the techniques were small but certainly not negligible. Most of the adaptations made were extra checks for types, for example when substituting some position with another term. 

Apart from the extra type checks, there have been more changes. A pertinent example in the graph of functional dependencies, where the definition had to be altered altogether to make it work for types.

\section{Experiments}
The results from all of the experiments match expectations. Semi-unification is often stronger than unification. It, together with the abstract unfolding technique, is the best at finding non-termination. What is not directly obvious, is if augmenting as a pre-processing step is always worth it. It usually leads to better results but it also takes considerably more time to calculate for problems that can be solved without augmenting, which may lead to timeouts. 

We were also able to find non-termination in one example where no other tool could. This was not with the ``strongest'' setup; rather with the concrete unfolding with semi-unification and without augmenting beforehand. This might also be the reason the other tools are not able to find this as they probably do not use concrete unfolding combined with unification.