\chapter{Semi Unification}\label{semi-unification}
Semi-unification is yet another way to detect non-termination. As its name suggests, it is somewhat like unification. It is actually a technique that encompasses both matching and unification. If we take two terms $t_1$ and $t_2$, matching creates a substitution $\rho$ such that $\rho(t_1) = t_2$ and unification creates a substitution $\sigma$ such that $\sigma(t_1) = \sigma(t_2)$. If we combine these, we get semi-unification:

\begin{definition}
Given two terms $t_1$ and $t_2$, $t_1$ and $t_2$ semi-unify if we can create two substitutions $\rho$ and $\sigma$ such that $\rho(\sigma(t_1)) = \sigma(t_2)$.
\end{definition}

It is clear that this encompasses both matching (take $\sigma = \emptyset$) and unification (take $\rho = \emptyset$). 

Semi-unification can detect non-termination of term rewriting rules, but also has other use cases, for example in type inference in Milner-Mycroft calculus\cite{Henglein:1988}. This calculus is used in some polymorphic functional programming languages. In the general case, semi-unification is undecidable\cite{KFOURY:1993}. In our case we are dealing with two input terms, for which semi-unification \textit{is} decidable.

The notion of semi-unification above is actually called left-unification. Right-unification can be calculated using left-unification if we swap the two input terms, so we would get $\sigma(t_1) = \rho(\sigma(t_2))$. Semi-unification captures both left- and right-unification.

An algorithm to compute semi-unification for two input terms is given in for example Kapur et al\cite{SemiUnification}. In the same paper a proof is also given how semi-unification can detect non-termination:

The idea is the same as with matching and unification, we will try to semi-unify the left hand side of a rule with some non-variable subterm on the right hand side. Suppose we have some rule $r_1: l \rightarrow r$. And $r'$ is a non-variable subterm of $r$. Now say that semi-unification is successful on $r'$, such that $\rho(\sigma(l)) \rightarrow \sigma(r')$. If we were to apply both the substitutions on the rule $r_1$ we would get $r_1': \rho(\sigma(l)) \rightarrow \rho(\sigma(r))$, for which we know there is some subterm $\rho(\sigma(r'))$ of $\rho(\sigma(r))$. This subterm is in its place equal to $\rho(\rho(\sigma(l)))$, because of the substitution we started with. Now we can rewrite this term to $\rho(\rho(\sigma(r)))$ and further repeat the last two steps indefinitely.

We will implement the algorithm described by Kapur et al for many-sorted term rewriting systems. The implementations are two separate algorithms, the first algorithm is sufficient to decide semi-unifiability, and as a result will generate a set of rewriting rules. But to obtain the substitutions, we need the second algorithm, it takes as an input the result from the first algorithm, then extracts the solution from it.

\section{Algorithm 1}
In the algorithm we will be looking for two substitutions $\sigma$ and $\rho$, such that for two terms $t_1$ and $t_2$, $\rho(\sigma(t_1)) = \sigma(t_2)$. To represent the $\sigma$ substitution, we use some special variables noted as $s_x$, this is the same as saying $\sigma(x)$. This mapping is captured in a substitution $\theta$, so we have for each variable $x$ in $t_1$ and $t_2$, $\theta(x) = s_x$. 

Before we can implement the algorithm itself, we need two notions of rewriting that are used within it. These are a notion of distributivity and a notion of cancellativity. 
\subsection{Distributivity}
Distributivity can be seen as ``pushing down'' the $\rho$ in a term. We know that $\rho$ is a substitution, so it will only have effect on variables. This means that we can ``push down'' the $\rho$ symbol in a term to the variable level:
$$ \rho(f(x_1, \dots, x_n)) = f(\rho(x_1), \dots, \rho(x_n)) $$
Note that this notion does not need adaptations for many-sorted terms, as the $\rho$ function its type is always the type of its argument. 
\subsection{Cancellativity}
Cancellativity of functions can be applied when we have two terms with the same root function symbol. When this is the case, we can cancel out the function symbol and result in $n$ new equations comparing the arguments (for $n$ arguments):
$$ f(x_1, \dots, x_n) = f(y_1, \dots, y_n) \implies x_1 = y_1, \dots, x_n = y_n $$
As before, this does not need any adaptations for many-sorted terms, the function symbol on the left is the exact same as on the right, so we do not need any type checks. 
\subsection{Implementation}
In Algorithm \ref{semiunification1} on page \pageref{semiunification1} the pseudocode is given for the algorithm. Note that the only places where we need to check for types is in line 6, comparing two function symbols, and when rewriting the rules in line 17. The fact that these checks are added means that the algorithm in some cases might perform better, since there are less possible ways to rewrite the rules.

The only ways the algorithm may report failure, is very close to the previously seen unification algorithm. Namely when either we reach a situation where we try to unify two terms with different function symbols, or when we try to unify some variable and non-variable term containing that variable. The latter is referred to as the ``occurs'' check. 

The proof of the full algorithm can be found in the paper\cite{SemiUnification}. Intuitively, the idea is to show that the only reasons semi-unification can fail is when either of the two ``failure'' situations arise. If these situations do not occur, then the first algorithm can be used to obtain the reduced canonical rewrite system. The second algorithm then can be used to extract $\sigma$ and $\rho$.  

\begin{algorithm}
\caption{Semi-Unification (Algorithm 1)}
\label{semiunification1}
\begin{algorithmic}[1]
\STATE Input terms $t_1$ and $t_2$
\STATE Begin with the equation $\rho(\sigma(t_1)) = \sigma(t_2)$
\STATE Apply distributivity rules on both sides of the equation
\STATE Apply cancellativity rules on both sides of the equation
\FORALL {Equations resulting from the cancellativity}
  \IF {An equation in the form of $f(x_1, \dots, x_n) = g(y_1, \dots, y_n)$ is encountered, with $f \neq g$ \OR $n \neq m$ }
    \RETURN Failure
  \ELSIF {An equation in the form of $\rho^i(s_x) = f(\dots \rho^{i + j}(s_x) \dots)$ is encountered, where the right side means that there is some subterm $\rho^{i + j}(s_x)$ in it, with $i, j \in \mathbb{N}$}
    \RETURN Failure
  \ENDIF
\ENDFOR
\STATE \COMMENT {Now we rewrite the equations into rules}:
\STATE Define a total ordering on the range of $\theta$ (all the $s_x$ terms)
\STATE Terms containing function symbols (other than $\rho$) are considered lower than ones that do not
\STATE Other terms are compared by their variables (in lexicographic order from right to left) using the total ordering on $\theta$ 
\STATE Now, for each rule, try to rewrite both sides using other rules. If this can be done, replace the rewritten rule by the result.
\STATE If this can be done, go back to to line 3 with this equation. 
\STATE Otherwise, report semi-unifiability, and return the resulting rules. 
\end{algorithmic}
\end{algorithm}

\section{Algorithm 2} 
Even though the first algorithm described above suffices to detect semi-unification, we will still implement the second algorithm to extract the substitutions from the resulting rules. We will do this because, even though we are certain the algorithm is correct, it is still a rather complex algorithm in which small mistakes could easily be made. By implementing the second algorithm, we have a double check to ensure that the result is actually correct. If, after applying the second algorithm, the terms do not semi-unify with the substitutions, we can deny semi-unifiability.
\subsection{Implementation}
The algorithm can be found in Algorithm \ref{semiunification2} on page \pageref{semiunification2}. Note that here too, not many changes need to be made in order to make the algorithm work for many-sorted terms. The most important points are in lines 4 and 17, where new fresh variables are created. These variables need to have the correct typing. On line 4, this means that the variable $u$ should have the same type as variable $x$. On line 17, this means that all the fresh variables need to have the same type as term $t$. This algorithm is also implemented in my fork of Cora as an analyser called \texttt{SemiUnificationAnalyzer}.

\begin{algorithm}
\caption{Semi-Unification (Algorithm 2)}
\label{semiunification2}
\begin{algorithmic}[1]
\STATE Input: rules resulting from algorithm 1
\STATE Initialise $\rho = \emptyset$, $\sigma = \emptyset$ and $\mathcal{V} = V$
\FORALL {Subterms like $\rho(s_x)$ in all right hand sides}
  \STATE Create fresh variable $u$
  \STATE Extend $\theta$ with $\theta(u) = s_u$
  \STATE $\mathcal{V} = \mathcal{V} \cup \{ u \}$
  \STATE Extend $\rho$ with $\rho(x) = u$
\ENDFOR
\FORALL {Rules in which $\rho$ does not occur}
  \STATE Left hand side is $s_x$
  \IF {Right hand side does not contain $s_x$}
    \STATE Extend $\sigma$ with $\sigma(x) = \theta^{-1}(r)$, $r$ is the right hand side
  \ENDIF
\ENDFOR
\FORALL {Rules in which $\rho$ \textit{does} occur}
  \STATE Rule is in the form $\rho^i(s_x) \rightarrow t$ with $i \in \mathbb{Z}^+$
  \STATE Introduce fresh variables $u_1, \dots, u_{i-1}$
  \STATE Extend $\rho$ with: $\rho(x) = u_1$, $\rho(u_1) = u_2$, \dots, $\rho(u_{i-1}) = \theta^{-1}(t)$
\ENDFOR
\end{algorithmic}
\end{algorithm}

\section{Examples}
Now we will look at some examples too see the workings of both of the algorithms described above. The first example we will look at is the rule $r_1 : f(g(x), x, h(y)) \rightarrow f(y, x, h(g(x)))$. The second example is the rule $r_2 : g(f(x, y), h(y, z)) \rightarrow g(z, x)$, which is an adaptation of an example from \cite{SemiUnification}. 
\subsection*{Example 1}
The first example we will look at is $r_1 : f(g(x), x, h(y)) \rightarrow f(y, x, h(g(x)))$, which is an example that is semi-unifiable, typed as follows: 
$$
\begin{array}{rcl}
    f & :: & a \rightarrow b \rightarrow c \rightarrow a \\
    g & :: & b \rightarrow a \\
    h & :: & a \rightarrow c 
\end{array}
$$
\subsubsection*{Algorithm 1}
We start with two input terms which are the left and right side of the rule: $t_1 = f(g(x), x, h(y))$ and $t_2 = f(y, x, h(g(x)))$.

We then ``apply'' the substitutions to get to the form $\rho(\sigma(t_1)) = \sigma(t_2)$, in our case this is $\rho(\sigma(f(g(x), x, h(y)))) = \sigma(f(y, x, h(g(x))))$. We can rewrite the $\sigma$ substitutions here using the definition of the $\theta$ substitution: $\rho(f(g(s_x), s_x, h(s_y))) = f(s_y, s_x, h(g(s_x)))$.

The next step of the algorithm tells us to apply the distributivity rules to both sides of the equation, which in this case is only relevant on the left side, as the right side does not contain any $\rho$ symbols. ``Pushing down'' $\rho$, we get: $f(g(\rho(s_x)), \rho(s_x), h(\rho(s_y))) = f(s_y, s_x, h(g(s_x)))$.

Now that the $\rho$ symbols are on just the variables we can apply the cancellativity rules. This firstly results in three equations: $g(\rho(s_x)) = s_y$, $\rho(s_x) = s_x$ and $h(\rho(s_y)) = h(g(s_x))$. But since we can apply cancellativity on the last equation again, we have to do so. Doing that means we replace it with $\rho(s_y) = g(s_x)$.

We did not reach a situation where the occurs check was positive or a mismatching function symbol, so we can continue with the algorithm. In the next step we have to create rules from the obtained equations. In this situation we can get away with using the fact that terms containing function symbols should be on the right. This gives us the following three rules:
$$
\begin{array}{lrcl}
    r_{1,1}: & s_y & \rightarrow & g(\rho(s_x)) \\
    r_{1,2}: & \rho(s_x) & \rightarrow & s_x \\
    r_{1,3}: & \rho(s_y) & \rightarrow & g(s_x)
\end{array}
$$
Since we can rewrite $r_{1,1}$ using $r_{1,2}$, we are not done yet. Doing this rewriting results in $s_y = g(s_x)$, which we will replace rule $r_{1,1}$ by. But before we can possibly do more rewritings, we need to apply the distributivity and cancellativity rules to them and finally create a rule from it. The distributivity and cancellativity rules change nothing and the left term will stay as the left term. So now we have the following three rules:
$$
\begin{array}{lrcl}
    r_{1,1}: & s_y & \rightarrow & g(s_x) \\
    r_{1,2}: & \rho(s_x) & \rightarrow & s_x \\
    r_{1,3}: & \rho(s_y) & \rightarrow & g(s_x)
\end{array}
$$
There is another possible rewriting: $r_{1,3}$ using $r_{1,1}$. Applying the rewriting gives us $\rho(g(s_x)) = g(s_x)$, this time the distributivity results in $g(\rho(s_x)) = g(s_x)$ and cancellation will extract the equation $\rho(s_x) = s_x$ from it. This equation will transform into a rule as $\rho(s_x) \rightarrow s_x$. But since we already have this rule, we ignore it. This means we now have the following two rules:
$$
\begin{array}{lrcl}
    r_{1,1}: & s_y & \rightarrow & g(s_x) \\
    r_{1,2}: & \rho(s_x) & \rightarrow & s_x
\end{array}
$$
There is no way to rewrite this further which means that the first algorithm succeeded with as result $r_{1,1}$ and $r_{1,2}$.
\subsubsection{Algorithm 2}
Because the first algorithm succeeded we can now use the second algorithm to extract the solution from the resulting rules. 

In the first step we have to deal with all the $\rho(s_x)$ terms on the right hand sides, but in our rules there are none. 

In the second step we have to look at all the rules in which $\rho$ does not occur, this is $r_{1,1}$. The left hand side is $s_y$, since the right hand side does not contain $s_y$, we extend $\sigma$ with $\sigma(y) = \theta^{-1}(g(s_x)) = g(x)$.

In the last step we look at all the rules that \textit{do} contain $\rho$, which is $r_{1,2}$. The rule is in the form $\rho^i(s_x) \rightarrow t$ with $i=1$, $x = x$ and $t = s_x$, so we do not need any fresh variables and set $\rho(x) = \theta^{-1}(t) = x$.

That concludes the second algorithm, the resulting substitutions are $\rho = \{ x \leftarrow x \}$ and $\sigma = \{ g(x) \leftarrow y \}$. It is clear that these substitutions lead to equal terms, namely to $f(g(x), x, h(g(x)))$. We can do a final check to see if the typing in the substitutions is correct, which it is: $x$ gets replaced by $x$, which is an identity substitution. In $\sigma$, $y$, typed $a$, gets replaced by $g(x)$, which also has type $a$. 
\subsection*{Example 2}
Now we show an example where semi-unification fails. We do this with the rule $r_2 : g(f(x, y), h(y, z)) \rightarrow g(z, x)$, which is a slight variation of an example taken from \cite{SemiUnification}. In that paper, there was no typing, so we introduce it as follows:
$$
\begin{array}{rcl}
    f & :: & b \rightarrow c \rightarrow a \\
    g & :: & a \rightarrow b \rightarrow b \\
    h & :: & c \rightarrow a \rightarrow b 
\end{array}
$$
As before, we start with the left and right sides as the two input terms. After introducing the substitutions and pushing down, we get:
$$g(f(\rho(s_x), \rho(s_y)), h(\rho(s_y), \rho(s_z))) = g(s_z, s_x)$$
After applying cancellation, we result in two equations: $f(\rho(s_x), \rho(s_y)) = s_z$ and $h(\rho(s_y), \rho(s_z)) = s_x$, rewriting these into rules gives us the following two rules: 
$$
\begin{array}{lrcl}
    r_{2,1}: & s_z & \rightarrow & f(\rho(s_x), \rho(s_y)) \\
    r_{2,2}: & s_x & \rightarrow & h(\rho(s_y), \rho(s_z))
\end{array}
$$
We can rewrite $r_{2,1}$ using $r_{2,2}$ and result in $s_z = f(\rho(h(\rho(s_y), \rho(s_z))), \rho(s_y))$. Now note that after applying distributivity rules, we get: $$s_z = f(h(\rho(\rho(s_y)), \rho(\rho(s_z))), \rho(s_y))$$
This gives us a problem as the ``occurs'' check is positive, $s_z$ is contained within the right side. This means that the semi-unification algorithm failed.